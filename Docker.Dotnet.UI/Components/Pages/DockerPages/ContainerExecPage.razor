@page "/containers/{containerId}/exec"
@using Docker.Dotnet.UI.ViewModels
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@implements IDisposable

@inherits MyComponentBase<Docker.Dotnet.UI.ViewModels.ContainerExecViewModel>

<MudContainer MaxWidth="MaxWidth.False" Class="pa-0" Style="height: 100vh; display: flex; flex-direction: column;">
    <!-- Header Bar -->
    <MudPaper Class="pa-3" Elevation="2" Square="true">
        <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                <MudIconButton Icon="@Icons.Material.Filled.ArrowBack"
                               Color="Color.Primary"
                               Href="/containers"
                               title="@Localizer["BACK"]"/>
                <MudText Typo="Typo.h6">
                    <MudIcon Icon="@Icons.Material.Filled.Terminal" Class="mr-1"/>
                    @Localizer["CONTAINER_TERMINAL"] - @Vm!.ContainerName
                </MudText>
            </MudStack>
            <MudStack Row="true" Spacing="2">
                @if (Vm!.IsConnected)
                {
                    <MudChip T="string" Color="Color.Success" Size="Size.Small">@Localizer["EXEC_CONNECTED"]</MudChip>
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Secondary"
                               Size="Size.Small"
                               StartIcon="@Icons.Material.Filled.Clear"
                               OnClick="@(() => Vm!.ClearTerminal())">
                        @Localizer["EXEC_CLEAR"]
                    </MudButton>
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Error"
                               Size="Size.Small"
                               StartIcon="@Icons.Material.Filled.Close"
                               OnClick="@(() => Vm!.CloseExecAsync())">
                        @Localizer["DISCONNECT"]
                    </MudButton>
                }
                else if (Vm!.IsConnecting)
                {
                    <MudChip T="string" Color="Color.Warning" Size="Size.Small">@Localizer["EXEC_CONNECTING"]</MudChip>
                }
                else
                {
                    <MudChip T="string" Color="Color.Error" Size="Size.Small">@Localizer["EXEC_DISCONNECTED"]</MudChip>
                    @if (!string.IsNullOrEmpty(Vm!.ContainerId))
                    {
                        <MudButton Variant="Variant.Filled"
                                   Color="Color.Primary"
                                   Size="Size.Small"
                                   StartIcon="@Icons.Material.Filled.Refresh"
                                   OnClick="@(() => Vm!.OpenExecAsync(Vm!.ContainerId!, Vm!.ContainerName ?? ""))">
                            @Localizer["EXEC_RECONNECT"]
                        </MudButton>
                    }
                }
            </MudStack>
        </MudStack>
    </MudPaper>

    @if (Vm?.HasError == true)
    {
        <MudAlert Severity="Severity.Error" Class="ma-2" ShowCloseIcon="true"
                  CloseIconClicked="@(() => Vm!.ErrorMessage = null)">
            @Vm!.ErrorMessage
        </MudAlert>
    }

    <!-- Terminal Area -->
    <div style="flex: 1; overflow: hidden; background-color: #1e1e1e; padding: 16px;">
        <div id="terminal-output"
             style="height: 100%; overflow-y: auto; color: #d4d4d4; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 14px; white-space: pre-wrap; word-wrap: break-word;">
            @foreach (var line in Vm!.TerminalOutput)
            {
                <text>@line</text>
            }
            @if (Vm!.IsConnecting)
            {
                <div>@Localizer["EXEC_CONNECTING"]</div>
            }
        </div>
    </div>

    <!-- Input Area -->
    @if (Vm!.IsConnected)
    {
        <MudPaper Class="pa-2" Elevation="2" Square="true">
            <MudTextField @bind-Value="_inputCommand"
                          Placeholder="@Localizer["TYPE_COMMAND"]"
                          Variant="Variant.Outlined"
                          Margin="Margin.Dense"
                          Immediate="true"
                          OnKeyUp="HandleKeyPress"
                          @ref="_inputField"
                          Style="font-family: 'Consolas', 'Monaco', 'Courier New', monospace;"/>
        </MudPaper>
    }
</MudContainer>

@code {
    [Parameter]
    public string? ContainerId { get; set; }

    private string _inputCommand = string.Empty;
    private MudTextField<string>? _inputField;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender && !string.IsNullOrEmpty(ContainerId))
        {
            // Get container name from ID
            await Vm!.OpenExecAsync(ContainerId, ContainerId);
        }

        // Auto-scroll to bottom
        if (Vm?.TerminalOutput.Count > 0)
        {
            await ScrollToBottomAsync();
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(_inputCommand))
        {
            await Vm!.SendInputAsync(_inputCommand + "\n");
            _inputCommand = string.Empty;
            StateHasChanged();
        }
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            // This would use JSInterop in a real implementation
            // For now we just update state
            await Task.CompletedTask;
        }
        catch
        {
            // Ignore scroll errors
        }
    }

    public new async void Dispose()
    {
        if (Vm != null)
        {
            await Vm.CloseExecAsync();
        }
        base.Dispose();
    }
}
